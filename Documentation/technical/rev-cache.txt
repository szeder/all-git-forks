rev-cache
=========

The revision cache API ('rev-cache') provides a method for efficiently storing 
and accessing commit branch sections.  Such branch slices are defined by a 
series of end (interesting) and start (uninteresting) commits.  Each slice 
contains, per commit:

* All intra-slice topological relations, encoded into path "channels".
* Commit meta-data: type, SHA-1, date.
* Objects introduced in that commit, relative to slice (ie. only for non-start 
  commits).

Data structures are not exported, in part to keep git's global scope clean, but 
largely because they're pretty much useless outside rev-cache.


The Porcelain
-------------
For easy access to 'rev-cache' from scripts and other goodies there's a 
front-end called (surprise!) `rev-cache`.  Currently it's pretty shit, I'm not 
gonna lie to you, but for in-slice traversals it's feck-loads faster than 
`rev-list`.  With more output modes and stuff it could potentially be used by 
any (external) app in need of quick data.

At the moment it looks like this:

`git-rev-cache COMMAND [options] [<commit-id>...]`

With the commands:

`(none)`::
	Display caches.  Passing a slice hash will display detailed information 
	about that cache slice.  (not yet implemented)

`add`::
	Add revisions to the cache.  Reads commit ids from stdin, formatted as:
	`END END ... \--not START START ...`
+
Options:

`\--fresh`:: Exclude everything already in a cache slice.
`\--stdin`:: Also read commit ids from stdin (seperated by newline, `\--not` 
also valid).
`\--legs`:: Ensure branch has no "dangling" starts (ie. is self-contained).
`\--nosizes`:: Don't include sizes with objects.
`\--noobjects`:: Don't include non-commit objects.

`rm`::
	Delete a cache slice.  (not yet implemented)

`walk`::
	Walk a cache slice based on set of commits; formatted as add.
+
Options:

`\--objects`:: Include non-commit objects in traversal.


The API
-------

The API for 'rev-cache' is very simple.  You can find the function prototypes 
in `revision.h`.

`make_cache_slice`::

	Create a cache based on an a `rev_info` instance or `commit_list` s of 
	"ends" and "starts" (defaults to latter if `rev_info` pointer is NULL), 
	copying the cache SHA-1 into a passed pointer if non-zero.  A 
	`rev_cache_info` struct pointer can be passed to set options 
	(currently: include objects, sizes; make legs), while passing NULL will 
	set default options (objects, sizes, no legs).  A last parameter can 
	optionally recieve the final cache hash.

`get_cache_slice`::

	Given a commit SHA-1 `get_cache_slice` will search the slice index and 
	return, if found, the cache-identifying SHA-1.

`traverse_cache_slice`::

	Traverse a specified cache slice based on:

	* `rev_info` instance
	* Cache SHA-1 identifier
	* A starting commit and commit work list
	* Date of most oldest encountered interesting commit
	* Current `slop` (this and above mainly used in integration with revision 
	  walker)
	
+
The output is sent to a FILO `commit_list` "queue", and any commit 
boundaries are passed back into the work list.

`uninteresting_from_slices`::

	Will mark all end-commits in all cache slices as `UNINTERESTING` in the 
	passed `rev_info` instance.


Example Usage
-------------

Everything is pretty self-explanatory except for perhaps 
`traverse_cache_slice`.  Here are a few examples to demonstrate usage (note 
that I have know idea if these work or even compile, they're just outlines):

.Creating a slice
----
/* pretend you're a porcelain for rev-cache reading from the command line */
struct rev_info revs;
struct rev_cache_info rci;

init_revisions(&revs, 0);

flags = 0;
for (i = 1; i < argc; i++) {
	if (!strcmp(argv[i], "--not"))
		flags ^= UNINTERESTING;
	else if(!strcmp(argv[i], "--fresh"))
		uninteresting_from_slices(&revs, 0, 0 /* reserved: always 0 for now */);
	else
		handle_revision_arg(argv[i], &revs, flags, 1);
}

/* we want to explicitly set certain options */
rci.legs = 0;
rci.objects = 0;
rci.sizes = 1;

if (!make_cache_slice(&revs, 0, 0, &rci, cache_sha1))
	printf("made slice!  it's called %s\n", sha1_to_hex(cache_sha1));
----

.Traversing a slice
----
/* let's say you're walking the tree with a 'work' list of current heads and a 
 * FILO output list 'out' */
out = 0;
outp = &out;

while (work) {
	struct commit *commit = pop_commit(&work);
	struct object *object = &commit->object;
	unsigned char *cache_sha1;
	
	if (cache_sha1 = get_cache_slice(object->sha1)) {
		/* note that this will instatiate any topo-relations 
		 * as it goes */
		if (traverse_cache_slice(&revs, cache_sha1, 
			commit, 0, 0, /* use defaults */
			&outp, &work) < 0)
			die("I'm overreacting to a non-fatal cache error");
	} else {
		struct commit_list *parents = commit->parents;
		
		while (parents) {
			struct commit *p = parents->item;
			struct object *po = &p->object;
			
			parents = parents->next;
			if (po->flags & UNINTERESTING)
				continue;
			
			if (object->flags & UNINTERESTING)
				po->flags |= UNINTERESTING;
			else if (po->flags & SEEN)
				continue;
			
			if (!po->parsed)
				parse_commit(p);
			insert_by_date(p, &work);
		}
		
		if (object->flags & (SEEN | UNINTERESTING) == 0)
			outp = &commit_list_insert(commit, outp);
		object->flags |= SEEN;
	}
}
----

Of course some more contrived examples might be more helpful...

----
struct commit_list *ends, *starts;

commit_list_insert(head_commit, &ends);
make_cache_slice(0, ends, starts, 0, 0);
----

----
struct commit_list *work, *out, **outp = &out;
struct rev_info revs;

init_revisions(&revs, 0);
traverse_cache_slice(&revs, 
	get_cache_slice(head_commit->object.sha1), 
	head_commit, 
	0, 0, 
	&work, &outp);
----


Some Internals
--------------

Although you really don't need to know anything about how rev-cache actually 
does its magic shizz, a bit of background may go a long way if you're wading 
through the source.

A lot can be summarized in the `object_entry` struct:

----
struct object_entry {
	unsigned type : 3;
	unsigned is_start : 1;
	unsigned is_end : 1;
	unsigned uninteresting : 1;
	unsigned include : 1;
	unsigned flags : 1;
	unsigned char sha1[20];
	
	unsigned merge_nr : 6;
	unsigned split_nr : 7;
	unsigned size_size : 3;
	
	unsigned long date;
	unsigned short path;
	
	/* merge paths */
	/* split paths */
	/* size */
};
----

With the exception of the `uninteresting` and `include` flags (which are 
runtime flags), it's pretty much a verbatim description of the object storage.  
Object entries, on disk and in memory, are *not* fixed sizes, as they require 
extra space to encode topo and size data.

`type`, `sha1` and `date` are self-explanatory.  `is_start` means that not all 
its parents are contained in the slice, and `is_end` notes that it is not the 
parent of anything in the slice.  `size_size` tells us how many bytes the size 
takes up -- note that it dosn't need any special encoding.

Now comes the interesting bit.  Topological relations are encoded via a 
path/channel system, where every branch is assigned an identifier, unique 
during its life-time (and a bit longer).  During traversal these are indices in 
a `path` array, retaining the status of each path.  Interesting paths have 
`IPATH`, uninterestings ones `UPATH` (which trumps `IPATH`) and inactive ones 
`0`.

Obivously, the `path` field delimits the current path id.  Any merge commit 
needs to open new paths, and does this via the `merge paths` section of its 
entry.  Likewise branching commits have to close paths, although this is a 
slight bit more complicated:

Because we a) need to restore topo-relations and b) need to keep track of 
boundary commits, a `last_objects` list keeps track of the last commit 
encountered per path.  This needs to be alive until *all* its parents have been 
seen, so path ids are actually unique up through a branch's last parent.  Such 
uniqueness is achieved by "stopping" paths at a merge, and a counter system to 
document how many parents have yet to be seen.

If we do encounter a boundary commit (which includes, but is not limited to, 
start commits), we have to ensure that *all* its associated objects are 
parsed.  Normally we use a `FACE_VALUE` flag to prevent `list-objects` from 
parsing trees and whatnot -- so we can directly use our own object list -- but 
in this case we have to remove it and any half-finished topo-data we 
accumulated for it.

The rest should pretty much fall into place.  The index is just like a pack 
index, with it's own fanout array and all.  It's not a very complex bit of 
source by any means...


Author
------

Nick Edelen (sirnot@gmail.com)
