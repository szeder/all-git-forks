gitattributes API
=================

gitattributes mechanism gives a uniform way to associate various
attributes to set of paths.


Data Structure
--------------

`struct git_attr`::

	The internal representation of this structure is
	of no interest to the calling programs.  The name of the
	attribute can be retrieved by calling `git_attr_name()`.

`struct git_attr_check`::

	This structure represents a collection of `struct git_attrs`.
	It is passed to `git_check_attr()` function, specifying the
	attributes to check, and receives their values into a corresponding
	`struct git_attr_result`.

`struct git_attr_result`::

	This structure represents one results for a check, such that an
	array of `struct git_attr_results` corresponds to a
	`struct git_attr_check`. The answers given in that array are in
	the the same order as the check struct.


Attribute Values
----------------

An attribute for a path can be in one of four states: Set, Unset,
Unspecified or set to a string, and `.value` member of `struct
git_attr_result` records it.  There are three macros to check these:

`ATTR_TRUE()`::

	Returns true if the attribute is Set for the path.

`ATTR_FALSE()`::

	Returns true if the attribute is Unset for the path.

`ATTR_UNSET()`::

	Returns true if the attribute is Unspecified for the path.

If none of the above returns true, `.value` member points at a string
value of the attribute for the path.


Querying Specific Attributes
----------------------------

* Prepare a `struct git_attr_check` using `git_attr_check_initl()` or
  `git_attr_check_initv()` function, enumerating the names of
  attributes whose values you are interested in, terminated with
  a NULL.
  Preparing the `struct git_attr_check` is thread safe, i.e. you
  can call it from different threads at the same time; when check
  determines the initialization is still needed, the threads will
  use a single global mutex to perform the initialization just once,
  the others will wait on the the thread to actually perform the
  initialization.

* Allocate an array of `struct git_attr_result` either on the stack
  or via `git_attr_result_alloc` on the heap when the result size
  is not known at compile time.

* Call `git_check_attr()` to check the attributes for the path,
  the given `git_attr_result` will be filled with the result.
  You must not change the `struct git_attr_check` after calling
  `git_check_attr()`.

* Inspect each `git_attr_result` structure to see how
  each of the attribute in the array is defined for the path.

Example
-------

To see how attributes "crlf" and "ident" are set for different paths.

. Prepare a `struct git_attr_check` with two elements (because
  we are checking two attributes) and then call `git_check_attr()`
  with the prepared `struct git_attr_check`:

------------
	const char *path;
	struct git_attr_result result[2];
	static struct git_attr_check *check;

	git_attr_check_initl(&check, "crlf", "ident", NULL);
	git_check_attr(path, check, result);
------------

. Act on `result.value[]`:

------------
	const char *value = result.value[0];

	if (ATTR_TRUE(value)) {
		The attribute is Set, by listing only the name of the
		attribute in the gitattributes file for the path.
	} else if (ATTR_FALSE(value)) {
		The attribute is Unset, by listing the name of the
		attribute prefixed with a dash - for the path.
	} else if (ATTR_UNSET(value)) {
		The attribute is neither set nor unset for the path.
	} else if (!strcmp(value, "input")) {
		If none of ATTR_TRUE(), ATTR_FALSE(), or ATTR_UNSET() is
		true, the value is a string set in the gitattributes
		file for the path by saying "attr=value".
	} else if (... other check using value as string ...) {
		...
	}
------------

To see how attributes in argv[] are set for different paths, use
`git_attr_check_initv` instead. When an invalid attr name is given
both init functions die unconditionally with a non user friendly message.
So you want to check the attr values first:

------------
static struct git_attr_check *check;
static void setup_check(const char **argv)
{
	const char **argv_copy = argv;
	while (*argv_copy) {
		const char *name = argv_copy[0];
		const int len = strlen(argv_copy[0]);
		if (!attr_name_valid(name, len)) {
			struct strbuf sb = STRBUF_INIT;
			invalid_attr_name_message(&sb, name, len);
			die ("Oops this is bad: %s", sb.buf);
		}
		argv_copy++;
	}
	git_attr_check_initv(&check, argv);
	struct git_attr_result *result = git_attr_result_alloc(check);
}
------------


Querying All Attributes
-----------------------

To get the values of all attributes associated with a file:

* Setup a local variables for the question
  `struct git_attr_check` as well as a pointer where the result
  `struct git_attr_result` will be stored. Both should be initialized
  to NULL.

------------
  struct git_attr_check *check = NULL;
  struct git_attr_result *result = NULL;
------------

* Call `git_all_attrs()`.

------------
  git_all_attrs(full_path, &check, &result);
------------

* Iterate over the `git_attr_check.attr[]` array to examine the
  attribute names.  The name of the attribute described by a
  `git_attr_check.attr[]` object can be retrieved via
  `git_attr_name(check->attr[i])`.  (Please note that no items
  will be returned for unset attributes, so `ATTR_UNSET()` will return
  false for all returned `git_array_check` objects.)
  The respective value for an attribute can be found in the same
  index position in of `git_attr_result`.

* Clear the variables by calling `git_attr_check_clear()` and
  `git_attr_result_free()`.
