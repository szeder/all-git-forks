gitattributes API
=================

gitattributes mechanism gives a uniform way to associate various
attributes to set of paths.


Data Structure
--------------

`struct git_attr`::

	An attribute is an opaque object that is identified by its name.
	Pass the name to `git_attr()` function to obtain the object of
	this type.  The internal representation of this structure is
	of no interest to the calling programs.  The name of the
	attribute can be retrieved by calling `git_attr_name()`.

`struct git_attr_check`::

	This structure represents a collection of `struct git_attrs`.
	It is passed to `git_check_attr()` function, specifying the
	attributes to check, and receives their values into a corresponding
	`struct git_attr_result`.

`struct git_attr_result`::

	This structure represents a collection of results to its
	corresponding `struct git_attr_check`, that has the same order.


Attribute Values
----------------

An attribute for a path can be in one of four states: Set, Unset,
Unspecified or set to a string, and `.value` member of `struct
git_attr_result` records it.  There are three macros to check these:

`ATTR_TRUE()`::

	Returns true if the attribute is Set for the path.

`ATTR_FALSE()`::

	Returns true if the attribute is Unset for the path.

`ATTR_UNSET()`::

	Returns true if the attribute is Unspecified for the path.

If none of the above returns true, `.value` member points at a string
value of the attribute for the path.


Querying Specific Attributes
----------------------------

* Prepare a `struct git_attr_check` using `git_attr_check_initl()`
  function, enumerating the names of attributes whose values you are
  interested in, terminated with a NULL pointer.  Alternatively, an
  empty `struct git_attr_check` as allocated by git_attr_check_alloc()
  can be prepared by calling `git_attr_check_alloc()` function and
  then attributes you want to ask about can be added to it with
  `git_attr_check_append()` function.
  `git_attr_check_initl()` is thread safe, i.e. you can call it
  from different threads at the same time; when check determines
  the initialzisation is still needed, the threads will use a
  single global mutex to perform the initialization just once, the
  others will wait on the the thread to actually perform the
  initialization.

* Prepare a `struct git_attr_result` using `GIT_ATTR_RESULT_INIT_FOR()`
  for the result for static allocations. When the result size is not known
  at compile time, use `git_attr_result_alloc`. The call to initialize
  the result is not thread safe, because different threads need their
  own thread local result anyway.

* Call `git_check_attr()` to check the attributes for the path,
  the given `git_attr_result` will be filled with the result.

* Inspect the returned `git_attr_result` structure to see how
  each of the attribute in the array is defined for the path.

Example
-------

To see how attributes "crlf" and "ident" are set for different paths.

. Prepare a `struct git_attr_check` with two elements (because
  we are checking two attributes):

------------
	static struct git_attr_check *check;
	git_attr_check_initl(check, "crlf", "ident", NULL);
------------

. Call `git_check_attr()` with the prepared `struct git_attr_check`:

------------
	const char *path;
	GIT_ATTR_RESULT_INIT_FOR(result, 2);

	git_check_attr(path, check, result);
------------

. Act on `result->value[]`:

------------
	const char *value = result->value[0];

	if (ATTR_TRUE(value)) {
		The attribute is Set, by listing only the name of the
		attribute in the gitattributes file for the path.
	} else if (ATTR_FALSE(value)) {
		The attribute is Unset, by listing the name of the
		attribute prefixed with a dash - for the path.
	} else if (ATTR_UNSET(value)) {
		The attribute is neither set nor unset for the path.
	} else if (!strcmp(value, "input")) {
		If none of ATTR_TRUE(), ATTR_FALSE(), or ATTR_UNSET() is
		true, the value is a string set in the gitattributes
		file for the path by saying "attr=value".
	} else if (... other check using value as string ...) {
		...
	}
------------

To see how attributes in argv[] are set for different paths, only
the first step in the above would be different.

------------
static struct git_attr_check *check;
static void setup_check(const char **argv)
{
	if (check)
		return; /* already done */
	check = git_attr_check_alloc();
	while (*argv) {
		struct git_attr *attr = git_attr(*argv);
		git_attr_check_append(check, attr);
		argv++;
	}
	struct git_attr_result *result = git_attr_result_alloc(check);
}
------------


Querying All Attributes
-----------------------

To get the values of all attributes associated with a file:

* Setup a local variables for the question
  `struct git_attr_check` as well as a pointer where the result
  `struct git_attr_result` will be stored.

* Call `git_all_attrs()`.

* Iterate over the `git_attr_check.attr[]` array to examine the
  attribute names.  The name of the attribute described by a
  `git_attr_check.attr[]` object can be retrieved via
  `git_attr_name(check->attr[i])`.  (Please note that no items
  will be returned for unset attributes, so `ATTR_UNSET()` will return
  false for all returned `git_array_check` objects.)
  The respective value for an attribute can be found in the same
  index position in of `git_attr_result`.

* Clear the variables by calling `git_attr_check_clear()` and
  `git_attr_result_free()`.
