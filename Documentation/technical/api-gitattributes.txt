gitattributes API
=================

gitattributes mechanism gives a uniform way to associate various
attributes to set of paths.


Data Structure
--------------

extern struct git_attr *git_attr(const char *);

/*
 * Return the name of the attribute represented by the argument.  The
 * return value is a pointer to a null-delimited string that is part
 * of the internal data structure; it should not be modified or freed.
 */
extern const char *git_attr_name(const struct git_attr *);

extern int attr_name_valid(const char *name, size_t namelen);
extern void invalid_attr_name_message(struct strbuf *, const char *, int);

`struct git_attr`::

	An attribute is an opaque object that is identified by its name.
	Pass the name to `git_attr()` function to obtain the object of
	this type.  The internal representation of this structure is
	of no interest to the calling programs.  The name of the
	attribute can be retrieved by calling `git_attr_name()`.

`struct git_attr_check`::

	This structure represents a collection of `struct git_attrs`.
	It is passed to `git_check_attr()` function, specifying the
	attributes to check, and receives their values into a corresponding
	`struct git_attr_result`.

`struct git_attr_result`::

	This structure represents a collection of results to its
	corresponding `struct git_attr_check`, that has the same order.


Attribute Values
----------------

An attribute for a path can be in one of four states: Set, Unset,
Unspecified or set to a string, and `.value` member of `struct
git_attr_check` records it.  There are three macros to check these:

`ATTR_TRUE()`::

	Returns true if the attribute is Set for the path.

`ATTR_FALSE()`::

	Returns true if the attribute is Unset for the path.

`ATTR_UNSET()`::

	Returns true if the attribute is Unspecified for the path.

If none of the above returns true, `.value` member points at a string
value of the attribute for the path.


Querying Specific Attributes
----------------------------

* Prepare `struct git_attr_check` using git_attr_check_initl()
  function, enumerating the names of attributes whose values you are
  interested in, terminated with a NULL pointer.  Alternatively, an
  empty `struct git_attr_check` as alloced by git_attr_check_alloc()
  can be prepared by calling `git_attr_check_alloc()` function and
  then attributes you want to ask about can be added to it with
  `git_attr_check_append()` function.
  git_attr_check_initl is thread safe, i.e. you can call it
  from different threads at the same time; internally however only one
  call at a time is processed. If the calls from different threads have
  the same arguments, the returned `git_attr_check` may be the same.

* Call `git_check_attr()` to check the attributes for the path,
  the returned `git_attr_result` contains the result.

* Inspect the returned `git_attr_result` structure to see how
  each of the attribute in the array is defined for the path.

* Do not free the result as the memory is owned by the attr subsystem.

Example
-------

To see how attributes "crlf" and "ident" are set for different paths.

. Prepare a `struct git_attr_check` with two elements (because
  we are checking two attributes):

------------
static struct git_attr_check *check;
static void setup_check(void)
{
	if (check)
		return; /* already done */
	check = git_attr_check_initl("crlf", "ident", NULL);
}
------------

. Call `git_check_attr()` with the prepared `struct git_attr_check`:

------------
	const char *path;
	struct git_attr_result *result;

	setup_check();
	result = git_check_attr(path, check);
------------

The `result` must not be free'd as it is owned by the attr subsystem.
It is reused by the same thread, so a subsequent call to git_check_attr
in the same thread will overwrite the result.

. Act on `result->value[]`:

------------
	const char *value = result->value[0];

	if (ATTR_TRUE(value)) {
		The attribute is Set, by listing only the name of the
		attribute in the gitattributes file for the path.
	} else if (ATTR_FALSE(value)) {
		The attribute is Unset, by listing the name of the
		attribute prefixed with a dash - for the path.
	} else if (ATTR_UNSET(value)) {
		The attribute is neither set nor unset for the path.
	} else if (!strcmp(value, "input")) {
		If none of ATTR_TRUE(), ATTR_FALSE(), or ATTR_UNSET() is
		true, the value is a string set in the gitattributes
		file for the path by saying "attr=value".
	} else if (... other check using value as string ...) {
		...
	}
------------

To see how attributes in argv[] are set for different paths, only
the first step in the above would be different.

------------
static struct git_attr_check *check;
static void setup_check(const char **argv)
{
	if (check)
		return; /* already done */
	check = git_attr_check_alloc();
	while (*argv) {
		struct git_attr *attr = git_attr(*argv);
		git_attr_check_append(check, attr);
		argv++;
	}
}
------------


Querying All Attributes
-----------------------

To get the values of all attributes associated with a file:

* Setup a local variables on the stack for both the question
  `struct git_attr_check` as well as the result `struct git_attr_result`.
  Zero them out via their respective _INIT macro.

* Call `git_all_attrs()`

* Iterate over the `git_attr_check.attr[]` array to examine the
  attribute names.  The name of the attribute described by a
  `git_attr_check.attr[]` object can be retrieved via
  `git_attr_name(check->attr[i])`.  (Please note that no items
  will be returned for unset attributes, so `ATTR_UNSET()` will return
  false for all returned `git_array_check` objects.)
  The respective value for an attribute can be found in the same
  index position in of `git_attr_result`.

* Clear the local variables by calling `git_attr_check_clear()` and
  `git_attr_result_clear()`.
