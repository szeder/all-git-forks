From: Junio C Hamano <gitster@pobox.com>
Date: Wed, 21 Nov 2007 16:32:55 -0800
Subject: Addendum to "MaintNotes"
Abstract: Imagine that git development is racing along as usual, when our friendly
 neighborhood maintainer is struck down by a wayward bus. Out of the
 hordes of suckers (loyal developers), you have been tricked (chosen) to
 step up as the new maintainer. This howto will show you "how to" do it.
Content-type: text/asciidoc

How to maintain Git
===================

The maintainer's git time is spent on three activities.

 - Communication (45%)

   Mailing list discussions on general design, fielding user
   questions, diagnosing bug reports; reviewing, commenting on,
   suggesting alternatives to, and rejecting patches.

 - Integration (50%)

   Applying new patches from the contributors while spotting and
   correcting minor mistakes, shuffling the integration and
   testing branches, pushing the results out, cutting the
   releases, and making announcements.

 - Own development (5%)

   Scratching my own itch and sending proposed patch series out.

The policy on Integration is informally mentioned in "A Note
from the maintainer" message, which is periodically posted to
this mailing list after each feature release is made.

The policy.

 - Feature releases are numbered as vX.Y.Z and are meant to
   contain bugfixes and enhancements in any area, including
   functionality, performance and usability, without regression.

 - One release cycle for a feature release is expected to last for
   eight to ten weeks.

 - Maintenance releases are numbered as vX.Y.Z.W and are meant
   to contain only bugfixes for the corresponding vX.Y.Z feature
   release and earlier maintenance releases vX.Y.Z.V (V < W).

 - 'master' branch is used to prepare for the next feature
   release. In other words, at some point, the tip of 'master'
   branch is tagged with vX.Y.Z.

 - 'maint' branch is used to prepare for the next maintenance
   release.  After the feature release vX.Y.Z is made, the tip
   of 'maint' branch is set to that release, and bugfixes will
   accumulate on the branch, and at some point, the tip of the
   branch is tagged with vX.Y.Z.1, vX.Y.Z.2, and so on.

 - 'next' branch is used to publish changes (both enhancements
   and fixes) that (1) have worthwhile goal, (2) are in a fairly
   good shape suitable for everyday use, (3) but have not yet
   demonstrated to be regression free.  New changes are tested
   in 'next' before merged to 'master'.

 - 'pu' branch is used to publish other proposed changes that do
   not yet pass the criteria set for 'next'.

 - The tips of 'master' and 'maint' branches will not be rewound to
   allow people to build their own customization on top of them.
   Early in a new development cycle, 'next' is rewound to the tip of
   'master' once, but otherwise it will not be rewound until the end
   of the cycle.

 - Usually 'master' contains all of 'maint' and 'next' contains all
   of 'master'.  'pu' contains all the topics merged to 'next', but
   is rebuilt directly on 'master'.

 - The tip of 'master' is meant to be more stable than any
   tagged releases, and the users are encouraged to follow it.

 - The 'next' branch is where new action takes place, and the
   users are encouraged to test it so that regressions and bugs
   are found before new topics are merged to 'master'.


A typical git day for the maintainer implements the above policy
by doing the following:

 - Scan mailing list.  Respond with review comments, suggestions
   etc.  Kibitz.  Collect potentially usable patches from the
   mailing list.  Patches about a single topic go to one mailbox (I
   read my mail in Gnus, and type \C-o to save/append messages in
   files in mbox format).

 - Write his own patches to address issues raised on the list but
   nobody has stepped up solving.  Send it out just like other
   contributors do.

 - Review the patches in the saved mailboxes.  Edit proposed log
   message for typofixes and clarifications, and add Acks
   collected from the list.  Edit patch to incorporate "Oops,
   that should have been like this" fixes from the discussion.

 - Classify the collected patches and handle 'master' and
   'maint' updates:

   - Obviously correct fixes that pertain to the tip of 'maint'
     are directly applied to 'maint'.

   - Obviously correct fixes that pertain to the tip of 'master'
     are directly applied to 'master'.

   - Other topics are not handled in this step.

   This step is done with "git am".

     $ git checkout master    ;# or "git checkout maint"
     $ git am -3 -s mailbox
     $ make test

 - Review the last issue of "What's cooking" message, review the
   topics scheduled for merging upwards (topic->master and
   topic->maint), and merge.  Use "Meta/cook -w" script (see later)
   to aid this step.

     $ git checkout master    ;# or "git checkout maint"
     $ git merge ai/topic     ;# or "git merge ai/maint-topic"
     $ git log -p ORIG_HEAD.. ;# final review
     $ git diff ORIG_HEAD..   ;# final review
     $ make test              ;# final review
XXX  $ git branch -d ai/topic ;# or "git branch -d ai/maint-topic"

 - Merge downwards (maint->master) if needed:

     $ git checkout master
     $ git merge maint
     $ make test

 - Merge downwards (master->next) if needed:

     $ git checkout next
     $ git merge master
     $ make test

 - Handle the remaining patches:

   - Anything unobvious that is applicable to 'master' (in other
     words, does not depend on anything that is still in 'next'
     and not in 'master') is applied to a new topic branch that
     is forked from the tip of 'master'.  This includes both
     enhancements and unobvious fixes to 'master'.  A topic
     branch is named as ai/topic where "ai" is two-letter string
     named after author's initial and "topic" is a descriptive name
     of the topic (in other words, "what's the series is about").

   - An unobvious fix meant for 'maint' is applied to a new
     topic branch that is forked from the tip of 'maint'.  The
     topic is named as ai/maint-topic.

   - Changes that pertain to an existing topic are applied to
     the branch, but:

     - obviously correct ones are applied first;

     - questionable ones are discarded or applied to near the tip;

   - Replacement patches to an existing topic are accepted only
     for commits not in 'next'.

   The above except the "replacement" are all done with:

     $ git checkout ai/topic ;# or "git checkout -b ai/topic master"
     $ git am -3 -s mailbox

   while patch replacement is often done by:

     $ git format-patch ai/topic~$n..ai/topic ;# export existing

   then replace some parts with the new patch, and reapplying:

     $ git checkout ai/topic
     $ git reset --hard ai/topic~$n
     $ git am -3 -s 000*.txt

   The full test suite is always run for 'maint' and 'master'
   after patch application; for topic branches the tests are run
   as time permits.

 - Review the last issue of "What's cooking" again and see if topics
   that were scheduled to be merged to 'next' are still in good
   shape (e.g. has there any new issue identified on the list with
   the series?)

 - Prepare 'jch' branch, which is used to represent somewhere
   between 'master' and 'pu' and often mirrors 'next'.

     $ Meta/Reintegrate master..pu >Meta/redo-jch.sh

   The result is a script that lists topics to be merged in order to
   rebuild 'pu' as the input to Meta/Reintegrate script.  Remove
   later topics that should not be in 'next' yet.

 - Merge topics to 'next'.  For each branch whose tip is not
   merged to 'next', one of three things can happen:

   - The commits are all next-worthy; merge the topic to next;
   - The new parts are of mixed quality, but earlier ones are
     next-worthy; merge the early parts to next;
   - Nothing is next-worthy; do not do anything.

   This step is aided with Meta/redo-jch.sh script created earlier.
   If a topic that was already in 'next' gained a patch, the script
   would list it as "ai/topic~1".  To include the new patch to the
   updated 'next', drop the "~1" part; to keep it excluded, do not
   touch the line.  If a topic that was not in 'next' should be
   merged to 'next', add it at the end of the list.  Then:

     $ git checkout -B jch master
     $ sh Meta/redo-jch.sh

   to rebuild the 'jch' branch from scratch.

   Then merge the same to 'next'

     $ git checkout next
     $ git merge master ;# may turn out to be "already up to date"
     $ sh Meta/redo-jch.sh -e

   The "-e" option allows the merge message that comes from the
   history of the topic and the comments in the "What's cooking" to
   be edited.  The resulting tree should match 'jch' as the same set
   of topics are merged on 'master'; otherwise there is a mismerge.

     $ git diff jch next

   When all is well, clean up the redo-jch.sh script with

     $ sh Meta/redo-jch.sh -u

   This removes topics listed in the script that have already been
   merged to 'master'.

 - Rebuild 'pu'.

     $ Meta/Reintegrate master..pu >Meta/redo-pu.sh

   Edit the result by adding new topics that are not still in 'pu'
   in the script.  Then

     $ git checkout -B pu jch
     $ sh Meta/redo-pu.sh

   When all is well, clean up the redo-pu.sh script with

     $ sh Meta/redo-pu.sh -u

 - Update "What's cooking" message to review the updates to
   existing topics, newly added topics and graduated topics.

   This step is helped with Meta/cook script (where Meta/ contains
   a checkout of the 'todo' branch).

     $ Meta/cook

   Look for lines enclosed in "<<" and ">>"; they hold contents from
   old file that are replaced by this integration round.  After
   verifying them, remove the old part.  Review the description for
   each topic and update its doneness and plan as needed.  To review
   the updated plan, run

     $ Meta/cook -w

   which will pick up comments given to the topics, such as "Will
   merge to 'next'", etc. (see Meta/cook script to learn what kind
   of phrases are supported).

 - Rebuild all four (five) integration branches; Meta/Dothem script
   may aid this step.

 - Rebuild documentation if the 'master' branch was updated;
   Meta/dodoc.sh script may aid this step.

 - Push four integration branches to public places.


Some observations to be made.

 * Each topic is tested individually, and also together with
   other topics cooking in 'next'.  Until it matures, no part
   of it is merged to 'master'.

 * A topic already in 'next' can get fixes while still in
   'next'.  Such a topic will have many merges to 'next' (in
   other words, "git log --first-parent next" will show many
   "Merge ai/topic to next" for the same topic.

 * An unobvious fix for 'maint' is cooked in 'next' and then
   merged to 'master' to make extra sure it is Ok and then
   merged to 'maint'.

 * Even when 'next' becomes empty (in other words, all topics
   prove stable and are merged to 'master' and "git diff master
   next" shows empty), it has tons of merge commits that will
   never be in 'master'.

 * In principle, "git log --first-parent master..next" should
   show nothing but merges (in practice, there are fixup commits
   and reverts that are not merges).

 * Commits near the tip of a topic branch that are not in 'next'
   are fair game to be discarded, replaced or rewritten.
   Commits already merged to 'next' will not be.

 * Being in the 'next' branch is not a guarantee for a topic to
   be included in the next feature release.  Being in the
   'master' branch typically is.
