#!/bin/sh

tsort() {
	perl -alne '
	BEGIN {
		my %visited;
		sub visit {
			my $n = shift;
			return () unless defined $edges{$n};
			return () if $visited{$n}++;
			return (visit($edges{$n}), $n);
		}
		sub tsort {
			return map { visit($_) }
			grep { !$incoming{$_} }
			@_;
		}
	}

	push @nodes, $F[0];
	$edges{$F[0]} = $F[1];
	$incoming{$F[1]}++;

	END {
		print "$_ $edges{$_}" for tsort(@nodes);
	}
	'
}

find_base() {
	if test "$rebase_on_upstream" = t; then
		echo "@{u}"
		return
	fi

	for reflog in `git rev-list -g $1 2>/dev/null`; do
		if test "$reflog" = "$(git merge-base $reflog HEAD)"; then
			echo $reflog
			return
		fi
	done
	git rev-parse -q --verify $1 2>/dev/null
}

cont=
rebase_on_upstream=
while test $# -gt 0; do
case "$1" in
--continue)
	cont=t
	;;
--upstream)
	rebase_on_upstream=t
	;;
*)
	echo >&2 "unknown option: $1"
	exit 1
esac
shift
done

GIT_DIR=`git rev-parse --git-dir` || exit

if test "$cont" = t; then
	if test -d "$GIT_DIR/rebase-merge" ||
	   test -d "$GIT_DIR/rebase-apply"; then
	  git rebase --continue || exit
	fi
else
	echo "Meta/rebase --continue" >"$GIT_DIR/continue"
fi

Meta/topics -u |
while read ref upstream; do
	echo $ref ${upstream:-origin}
done |
tsort |
while read i upstream; do
	case "$i" in
	*/maint-*)
		echo "===> Skipping $i (maint)"
		continue
		;;
	esac

	if test -z "`git rev-list -1 "$upstream" ^$i`"; then
		echo "===> Skipping $i"
		continue
	fi

	echo "===> Rebasing $i"
	git checkout -q $i &&
	if ! git rebase --onto $upstream `find_base $upstream`; then
		if test -z "`git ls-files -u`"; then
			echo >&2 Auto-continuing rebase via rerere...
			git rebase --continue || exit 1
		else
			exit 1
		fi
	fi
done &&
rm -f "$GIT_DIR/continue"
