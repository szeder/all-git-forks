#!/usr/bin/perl

use 5.008;
use warnings FATAL => 'all';
use strict;
use Algorithm::Diff;

# Highlight by reversing foreground and background. You could do
# other things like bold or underline if you prefer.
my @OLD_HIGHLIGHT = (
	color_config('color.diff-highlight.oldnormal'),
	color_config('color.diff-highlight.oldhighlight', "\x1b[7m"),
	color_config('color.diff-highlight.oldreset', "\x1b[27m")
);
my @NEW_HIGHLIGHT = (
	color_config('color.diff-highlight.newnormal', $OLD_HIGHLIGHT[0]),
	color_config('color.diff-highlight.newhighlight', $OLD_HIGHLIGHT[1]),
	color_config('color.diff-highlight.newreset', $OLD_HIGHLIGHT[2])
);

my $RESET = "\x1b[m";
my $COLOR = qr/\x1b\[[0-9;]*m/;
my $BORING = qr/$COLOR|\s/;

# The patch portion of git log -p --graph should only ever have preceding | and
# not / or \ as merge history only shows up on the commit line.
my $GRAPH = qr/$COLOR?\|$COLOR?\s+/;

my @removed;
my @added;
my $in_hunk;

# Some scripts may not realize that SIGPIPE is being ignored when launching the
# pager--for instance scripts written in Python.
$SIG{PIPE} = 'DEFAULT';

while (<>) {
	if (!$in_hunk) {
		print;
		$in_hunk = /^$GRAPH*$COLOR*\@\@ /;
	}
	elsif (/^$GRAPH*$COLOR*-/) {
		push @removed, $_;
	}
	elsif (/^$GRAPH*$COLOR*\+/) {
		push @added, $_;
	}
	else {
		show_hunk(\@removed, \@added);
		@removed = ();
		@added = ();

		print;
		$in_hunk = /^$GRAPH*$COLOR*[\@ ]/;
	}

	# Most of the time there is enough output to keep things streaming,
	# but for something like "git log -Sfoo", you can get one early
	# commit and then many seconds of nothing. We want to show
	# that one commit as soon as possible.
	#
	# Since we can receive arbitrary input, there's no optimal
	# place to flush. Flushing on a blank line is a heuristic that
	# happens to match git-log output.
	if (!length) {
		local $| = 1;
	}
}

# Flush any queued hunk (this can happen when there is no trailing context in
# the final diff of the input).
show_hunk(\@removed, \@added);

exit 0;

# Ideally we would feed the default as a human-readable color to
# git-config as the fallback value. But diff-highlight does
# not otherwise depend on git at all, and there are reports
# of it being used in other settings. Let's handle our own
# fallback, which means we will work even if git can't be run.
sub color_config {
	my ($key, $default) = @_;
	my $s = `git config --get-color $key 2>/dev/null`;
	return length($s) ? $s : $default;
}

sub show_hunk {
	my ($lines_a, $lines_b) = @_;

	# If one side is empty, then there is nothing to compare or highlight.
	if (!@$lines_a || !@$lines_b) {
		print @$lines_a, @$lines_b;
		return;
	}

	# Strip out any cruft so we can do the real diff on $a and $b.
	my ($a, @stripped_a) = strip_image(@$lines_a);
	my ($b, @stripped_b) = strip_image(@$lines_b);

	# Now we do the actual diff. Our highlight list is in the same
	# annotation format as the @stripped data.
	my $diff = Algorithm::Diff->new([split_image($a)], [split_image($b)]);
	my ($offset_a, $offset_b) = (0, 0);
	my (@highlight_a, @highlight_b);
	while ($diff->Next()) {
		my $bits = $diff->Diff();

		push @highlight_a, [$offset_a, $OLD_HIGHLIGHT[1]]
			if $bits & 1;
		$offset_a += length($_) for $diff->Items(1);
		push @highlight_a, [$offset_a, $OLD_HIGHLIGHT[2]]
			if $bits & 1;

		push @highlight_b, [$offset_b, $NEW_HIGHLIGHT[1]]
			if $bits & 2;
		$offset_b += length($_) for $diff->Items(2);
		push @highlight_b, [$offset_b, $NEW_HIGHLIGHT[2]]
			if $bits & 2;
	}

	my $highlighted = count_highlight(@highlight_a) +
			  count_highlight(@highlight_b);
	my $total = length($a) + length($b);
	my $pct = $highlighted / $total;

	if ($pct > 0.5) {
		@highlight_a = ();
		@highlight_b = ();
	}

	# And now show the output both with the original stripped annotations,
	# as well as our new highlights.
	show_image($a, [merge_annotations(\@stripped_a, \@highlight_a)]);
	show_image($b, [merge_annotations(\@stripped_b, \@highlight_b)]);
}

sub count_highlight {
	my $total = 0;
	while (@_) {
		my $from = shift;
		my $to = shift;
		$total += $to->[0] - $from->[0];
	}
	return $total;
}

# Strip out any diff syntax (i.e., leading +/-), along with any ANSI color
# codes from the pre- or post-image of a hunk. The result is a string of text
# suitable for diffing against the other side of the hunk.
#
# In addition to returning the hunk itself, we also return an arrayref that
# contains the stripped data.  Each element is itself an arrayref containing
# the offset into the stripped hunk, along with the stripped data that belongs
# there.
sub strip_image {
	my $image = '';
	my @stripped;
	foreach my $line (@_) {
		$line =~ s/^$COLOR*[+-]$COLOR*//
			or die "BUG: line was not +/-: $line";
		push @stripped, [length($image), $&];

		while (length($line)) {
			if ($line =~ s/^$COLOR+//) {
				push @stripped, [length($image), $&];
			} elsif ($line =~ s/^(.+?)($COLOR|$)/$2/s) {
				$image .= $1;
			} else {
				die "BUG: we should have matched _something_";
			}
		}
	}

	return $image, @stripped;
}

# Split the pre- or post-image into diffable elements. Returns
sub split_image {
	return split(/([A-Za-z0-9-]+)/, shift);
}

sub merge_annotations {
	my ($a, $b) = @_;
	my @r;
	while (@$a && @$b) {
		if ($a->[0]->[0] <= $b->[0]->[0]) {
			push @r, shift @$a;
		} else {
			push @r, shift @$b;
		}
	}
	push @r, @$a;
	push @r, @$b;
	return @r;
}

sub show_image {
	my ($image, $annotations) = @_;
	my $pos = 0;

	foreach my $an (@$annotations) {
		if ($pos < $an->[0]) {
			print substr($image, $pos, $an->[0] - $pos);
			$pos = $an->[0];
		}
		print $an->[1];
	}

	if ($pos < length($image)) {
		print substr($image, $pos);
	}
}
