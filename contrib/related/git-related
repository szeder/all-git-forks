#!/usr/bin/env ruby

# This script finds people that might be interested in a patch
# usage: git related <files | rev-list options>

$since = '5-years-ago'
$min_percent = 10
$files = []
$rev_args = []

KNOWN_ROLES = {
  'Signed-off' => :signer,
  'Reviewed' => :reviewer,
  'Acked' => :acker,
}

class Person

  attr_reader :roles

  def initialize(name, email)
    @name = name
    @email = email
    @commits = {}
    @roles = Hash.new(0)
  end

  def add_role(commit, role)
    @commits[commit] = true
    @roles[role] += 1
  end

  def <=>(b)
    self.size <=> b.size
  end

  def size
    @commits.size
  end

  def to_s
    '%s <%s>' % [@name, @email]
  end

end

class Persons

  @@index = {}

  include Enumerable

  def each(&block)
    @@index.values.each(&block)
  end

  def self.get(name, email)
    id = [name, email]
    person = @@index[id]
    if not person
      person = @@index[id] = Person.new(name, email)
    end
    person
  end

end

class Commit

  def initialize(id)
    @id = id
  end

  def parse(data)
    msg = author = nil
    data.each_line do |line|
      if not msg
        case line
        when /^author ([^<>]+) <(\S+)> (.+)$/
          author = Persons.get($1, $2)
          author.add_role(@id, :author)
        when /^$/
          msg = true
        end
      else
        role_regex = KNOWN_ROLES.keys.join('|')
        if line =~ /^(#{role_regex})-by: ([^<>]+) <(\S+?)>$/
          person = Persons.get($2, $3)
          role = KNOWN_ROLES[$1]
          next if role == :signer and person == author
          person.add_role(@id, role)
        end
      end
    end
  end

end

class Commits

  def initialize
    @items = {}
    @main_commits = {}
  end

  def size
    @items.size
  end

  def each(&block)
    @items.each(&block)
  end

  def import
    return if @items.empty?
    File.popen(%w[git cat-file --batch], 'r+') do |p|
      p.write(@items.keys.join("\n"))
      p.close_write
      p.each do |line|
        if line =~ /^(\h{40}) commit (\d+)/
          id, len = $1, $2
          data = p.read($2.to_i)
          @items[id].parse(data)
        end
      end
    end
  end

  def get_blame(source, start, len, from)
    return if len == 0
    len ||= 1
    File.popen(['git', 'blame', '--incremental', '-C', '-C',
               '-L', '%u,+%u' % [start, len],
               '--since', $since, from + '^',
               '--', source]) do |p|
      p.each do |line|
        if line =~ /^\h{40}/
          id = $&
          @items[id] = Commit.new(id) if not @main_commits.include?(id)
        end
      end
    end
  end

  def from_patches(files)
    source = nil
    files.each do |file|
      from = nil
      File.open(file) do |f|
        f.each do |line|
          case line
          when /^From (\h+) (.+)$/
            from = $1
            @main_commits[from] = true
          when /^---\s+(\S+)/
            source = $1 != '/dev/null' ? $1[2..-1] : nil
          when /^@@ -(\d+)(?:,(\d+))?/
            get_blame(source, $1, $2, from) if source and from
          end
        end
      end
    end
  end

  def from_rev_args(args)
    revs = []

    File.popen(%w[git rev-parse --revs-only --default HEAD --symbolic] + args).each do |rev|
      revs << rev.chomp
    end

    case revs.size
    when 1
      r = revs[0]
      r = '^' + r if r[0] != '-'
      args = [ r, 'HEAD' ]
    else
      args = revs
    end

    source = nil
    File.popen(%w[git rev-list --reverse] + args) do |p|
      p.each do |e|
        id = e.chomp
        @main_commits[id] = true
        File.popen(%w[git show -C --oneline] + [id]) do |p|
          p.each do |e|
            case e
            when /^---\s+(\S+)/
              source = $1 != '/dev/null' ? $1[2..-1] : nil
            when /^@@ -(\d+)(?:,(\d+))?/
              get_blame(source, $1, $2, id) if source
            end
          end
        end
      end
    end
  end

end

ARGV.each do |e|
  if File.exists?(e)
    $files << e
  else
    $rev_args << e
  end
end

commits = Commits.new
if $files.empty?
  commits.from_rev_args($rev_args)
else
  commits.from_patches($files)
end
commits.import

persons = Persons.new

persons.sort.reverse.each do |person|
  percent = person.size.to_f * 100 / commits.size
  next if percent < $min_percent

  roles = person.roles.map do |role, role_count|
    role_percent = role_count.to_f * 100 / commits.size
    '%s: %u%%' % [role, role_percent]
  end

  puts '%s (%s)' % [person, roles.join(', ')]
end
