#!/usr/bin/perl

# List people who might be interested in a patch.  Useful as the argument to
# git-send-email --cc-cmd option, and in other situations.
#
# Usage: git contacts <file | rev-list option> ...

use strict;
use warnings;
use IPC::Open2;

my $since = '5-years-ago';
my $min_percent = 10;
my $labels_rx = qr/(?:Signed-off|Reviewed|Acked)-by/;
my $id_rx = qr/[0-9a-f]{40}/i;
my %seen;

sub format_contact {
	my ($name, $email) = @_;
	return "$name <$email>";
}

sub parse_commit {
	my ($commit, $data) = @_;
	my $contacts = $commit->{contacts};
	my $inbody = 0;
	for (split(/^/m, $data)) {
		if (not $inbody) {
			if (/^author ([^<>]+) <(\S+)> .+$/) {
				$contacts->{format_contact($1, $2)} = 1;
			} elsif (/^$/) {
				$inbody = 1;
			}
		} elsif (/^$labels_rx:\s+([^<>]+)\s+<(\S+?)>$/o) {
			$contacts->{format_contact($1, $2)} = 1;
		}
	}
}

sub import_commits {
	my ($commits) = @_;
	return unless %$commits;
	my $pid = open2 my $reader, my $writer, qw(git cat-file --batch);
	for my $id (keys(%$commits)) {
		print $writer "$id\n";
		my $line = <$reader>;
		if ($line =~ /^($id_rx) commit (\d+)/o) {
			my ($cid, $len) = ($1, $2);
			die "expected $id but got $cid" unless $id eq $cid;
			my $data;
			# cat-file emits newline after data, so read len+1
			read $reader, $data, $len + 1;
			parse_commit($commits->{$id}, $data);
		}
	}
	close $reader;
	close $writer;
	waitpid($pid, 0);
	die "git-cat-file error: $?" if $?;
}

sub get_blame {
	my ($commits, $source, $start, $len, $from) = @_;
	$len = 1 unless defined($len);
	return if $len == 0;
	open my $f, '-|',
		qw(git blame --incremental -C -C), '-L', "$start,+$len",
		'--since', $since, "$from^", '--', $source or die;
	while (<$f>) {
		if (/^$id_rx/o) {
			my $id = $&;
			$commits->{$id} = { id => $id, contacts => {} }
				unless $seen{$id};
			$seen{$id} = 1;
		}
	}
	close $f;
}

sub scan_hunks {
	my ($commits, $id, $f) = @_;
	my $source;
	while (<$f>) {
		if (/^---\s+(\S+)/) {
			$source = substr($1, 2) unless $1 eq '/dev/null';
		} elsif (/^@@ -(\d+)(?:,(\d+))?/ && $source) {
			get_blame($commits, $source, $1, $2, $id);
		}
	}
}

sub commits_from_patch {
	my ($commits, $file) = @_;
	open my $f, '<', $file or die "read failure: $file: $!";
	my $id;
	while (<$f>) {
		if (/^From ($id_rx) /o) {
			$id = $1;
			$seen{$id} = 1;
			last;
		}
	}
	scan_hunks($commits, $id, $f) if $id;
	close $f;
}

sub parse_rev_args {
	my @args = @_;
	open my $f, '-|',
		qw(git rev-parse --revs-only --default HEAD --symbolic), @args
		or die;
	my @revs;
	while (<$f>) {
		chomp;
		push @revs, $_;
	}
	close $f;
	return @revs if scalar(@revs) != 1;
	return "^$revs[0]", 'HEAD' unless $revs[0] =~ /^-/;
	return $revs[0], 'HEAD';
}

sub commits_from_rev_args {
	my ($commits, $args) = @_;
	my @revs = parse_rev_args(@$args);
	open my $f, '-|', qw(git rev-list --reverse), @revs or die;
	while (<$f>) {
		chomp;
		my $id = $_;
		$seen{$id} = 1;
		open my $g, '-|', qw(git show -C --oneline), $id or die;
		scan_hunks($commits, $id, $g);
		close $g;
	}
	close $f;
}

my (@files, @rev_args);
for (@ARGV) {
	if (-e) {
		push @files, $_;
	} else {
		push @rev_args, $_;
	}
}

my %commits;
commits_from_patch(\%commits, $_) for (@files);
commits_from_rev_args(\%commits, \@rev_args) if @rev_args;
import_commits(\%commits);

my %count_per_person;
for my $commit (values %commits) {
	for my $contact (keys %{$commit->{contacts}}) {
		$count_per_person{$contact}++;
	}
}

my $ncommits = scalar(keys %commits);
for my $contact (keys %count_per_person) {
	my $percent = $count_per_person{$contact} * 100 / $ncommits;
	next if $percent < $min_percent;
	print "$contact\n";
}
